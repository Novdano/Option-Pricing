#print(res)
plot(r_T, res, main = "PnL against rebalancing", ylab = "PnL" , xlab = "rebalance period", type = "l", col = "blue")
BS_V0 <- function(S_0, K, r, sigma, T){
d1 <- (log(S_0/K) + (r + sigma^2/2)*T)/(sigma * sqrt(T))
d2 <- (log(S_0/K) + (r - sigma^2/2)*T)/(sigma * sqrt(T))
res <- S_0 * pnorm(d1) - K*pnorm(d2) * exp(-r * T)
return(res)
}
MC_BSV0 <- function(S_0, K, r, sigma, T, N, M){
payoff <- rep(0,M)
for (i in 1:M){
s <- S_0
for (n in 1:N){
s <- s + r*s*(T/N) + sigma * s * rnorm(1) * sqrt(T/N)
}
if (s>K){
payoff[[i]] <- s-K
} else{
payoff[[i]] <- 0
}
}
res <- (1 + r * (T/N))^-N * (mean(payoff))
return (res)
}
MC_SV0 <- function(S_0, K, r, sigma_0, kappa, theta, miu, rho, lambda, T, N, M){
payoff <- rep(0,M)
for (i in 1:M){
s <- S_0
v<- sigma_0
vols = rep(0,N)
for (n in 1:N){
gts = rnorm(1)
gtv = rnorm(1)
s <- s + r*s*(T/N) + sqrt(v) * s * gts * sqrt(T/N)
v <- v + kappa*(theta-v)*(T/N) - v*lambda*(T/N) + miu*sqrt(v)*sqrt(T/N)*(rho*(gts) + sqrt(1-rho^2)*gtv)
#vols[[n]] = v
}
#plot(c(1:N), vols,main = "vol evolution",ylab="Vols",xlab="Time",type="l")
if (s>K){
payoff[[i]] <- s-K
} else{
payoff[[i]] <- 0
}
}
res <- (1 + r * (T/N))^-N * mean(payoff)
return (res)
}
MC <- rep(0,40)
BS <- rep(0,40)
SV_10k <- rep(0,40)
SV_20k <- rep(0,40)
SV_30k <- rep(0,40)
for (i in 1:40){
MC[[i]] <- MC_BSV0(init_price, K+i, r, sigma, T, M, N)
BS[[i]] <- BS_V0(init_price, K+i, r, sigma, T)
SV_10k[[i]] <- MC_SV0(init_price, K+i, r, sigma^2, 1, 0.1, 0.001 ,-0, 20, T, M, N)
SV_20k[[i]] <- MC_SV0(init_price, K+i, r, sigma^2, 1 , 0.1, 0.001 ,-0, 20, T, M, N)
SV_30k[[i]] <- MC_SV0(init_price, K+i, r, sigma^2, 1, 0.1, 0.001 ,-0, 20, T, M, N)
}
plot(c(31:70), MC, main = "plot K = 50,...,70", ylab = "Price", xlab="Strike", type = "l", col = "blue", ylim=c(0,40))
lines(31:70, BS, col = "red")
lines(31:70, SV_10k, col = "green")
lines(31:70, SV_20k, col = "pink")
lines(31:70, SV_30k, col = "black")
legend("topright",
c("MonteCarlo","BlackScholes", "0.001T","0.05T","0.01T"),
fill=c("blue","red", "green","pink","black"))
MC <- rep(0,40)
BS <- rep(0,40)
SV_10k <- rep(0,40)
SV_20k <- rep(0,40)
SV_30k <- rep(0,40)
for (i in 1:40){
MC[[i]] <- MC_BSV0(init_price, K+i, r, sigma, T, M, N)
BS[[i]] <- BS_V0(init_price, K+i, r, sigma, T)
SV_10k[[i]] <- MC_SV0(init_price, K+i, r, sigma^2, 1, 0.1, 0.001 ,-0, 1, T, M, N)
SV_20k[[i]] <- MC_SV0(init_price, K+i, r, sigma^2, 1 , 0.1, 0.001 ,-0, 10, T, M, N)
SV_30k[[i]] <- MC_SV0(init_price, K+i, r, sigma^2, 1, 0.1, 0.001 ,-0, 20, T, M, N)
}
plot(c(31:70), MC, main = "plot K = 50,...,70", ylab = "Price", xlab="Strike", type = "l", col = "blue", ylim=c(0,40))
lines(31:70, BS, col = "red")
lines(31:70, SV_10k, col = "green")
lines(31:70, SV_20k, col = "pink")
lines(31:70, SV_30k, col = "black")
legend("topright",
c("MonteCarlo","BlackScholes", "0.001T","0.05T","0.01T"),
fill=c("blue","red", "green","pink","black"))
knitr::opts_chunk$set(echo = TRUE)
Hedge_Simulation <- function(S_0, K, r, sigma, T, M, N, reb_t){
pnl_mast <- 0
reb_n <- round(reb_t * N)
for (i in 1:M){
s  <- S_0
#if long, the pnl is negative, if short then pnl is positive
pnl_start <- -BS_Call(S_0, K, r, sigma, T) - BS_Put(S_0,K,r,sigma,T)
num_stock <- Call_Delta(S_0, K, r, sigma, T) + Put_Delta(S_0,K,r,sigma, T)
pnl_start <- pnl_start + num_stock*S_0
for (n in 1:N){
#print(num_stock)
s <- s + r*s*(T/N) + sigma * s * rnorm(1) * sqrt(T/N)
if (n %% reb_n == 0){
#print(T-(n/N)*T)
d_call <- Call_Delta(s, K, r, sigma, T-(n/N)*T)
d_put <- Put_Delta(s, K, r, sigma, T-(n/N)*T)
d_tot <- d_call + d_put
num_stock <- d_tot - num_stock
print(num_stock*S)
pnl_start <- pnl_start + num_stock * s
}
}
if (s>=K){
pnl_start <- pnl_start + s-K
} else {
pnl_start <- pnl_start + K-s
}
pnl_mast <- pnl_mast + pnl_start - num_stock * s
}
return (pnl_mast/M)
}
r_T <- c(1/365, 1/52, 1/12, 1/2, 1)
res <- rep(0,5)
for (i in 1:5){
res[[i]] <- Hedge_Simulation(43,43,0.02,0.023,1,100,1000,r_T[[i]])
}
print(num_stock*s)
Hedge_Simulation <- function(S_0, K, r, sigma, T, M, N, reb_t){
pnl_mast <- 0
reb_n <- round(reb_t * N)
for (i in 1:M){
s  <- S_0
#if long, the pnl is negative, if short then pnl is positive
pnl_start <- -BS_Call(S_0, K, r, sigma, T) - BS_Put(S_0,K,r,sigma,T)
num_stock <- Call_Delta(S_0, K, r, sigma, T) + Put_Delta(S_0,K,r,sigma, T)
pnl_start <- pnl_start + num_stock*S_0
for (n in 1:N){
#print(num_stock)
s <- s + r*s*(T/N) + sigma * s * rnorm(1) * sqrt(T/N)
if (n %% reb_n == 0){
#print(T-(n/N)*T)
d_call <- Call_Delta(s, K, r, sigma, T-(n/N)*T)
d_put <- Put_Delta(s, K, r, sigma, T-(n/N)*T)
d_tot <- d_call + d_put
num_stock <- d_tot - num_stock
print(num_stock*s)
pnl_start <- pnl_start + num_stock * s
}
}
if (s>=K){
pnl_start <- pnl_start + s-K
} else {
pnl_start <- pnl_start + K-s
}
pnl_mast <- pnl_mast + pnl_start - num_stock * s
}
return (pnl_mast/M)
}
r_T <- c(1/365, 1/52, 1/12, 1/2, 1)
res <- rep(0,5)
for (i in 1:5){
res[[i]] <- Hedge_Simulation(43,43,0.02,0.023,1,100,1000,r_T[[i]])
}
Hedge_Simulation <- function(S_0, K, r, sigma, T, M, N, reb_t){
pnl_mast <- 0
reb_n <- round(reb_t * N)
for (i in 1:M){
s  <- S_0
#if long, the pnl is negative, if short then pnl is positive
pnl_start <- -BS_Call(S_0, K, r, sigma, T) - BS_Put(S_0,K,r,sigma,T)
num_stock <- Call_Delta(S_0, K, r, sigma, T) + Put_Delta(S_0,K,r,sigma, T)
pnl_start <- pnl_start + num_stock*S_0
for (n in 1:N){
#print(num_stock)
s <- s + r*s*(T/N) + sigma * s * rnorm(1) * sqrt(T/N)
if (n %% reb_n == 0){
#print(T-(n/N)*T)
d_call <- Call_Delta(s, K, r, sigma, T-(n/N)*T)
d_put <- Put_Delta(s, K, r, sigma, T-(n/N)*T)
d_tot <- d_call + d_put
num_stock <- d_tot - num_stock
print(num_stock)
pnl_start <- pnl_start + num_stock * s
}
}
if (s>=K){
pnl_start <- pnl_start + s-K
} else {
pnl_start <- pnl_start + K-s
}
pnl_mast <- pnl_mast + pnl_start - num_stock * s
}
return (pnl_mast/M)
}
r_T <- c(1/365, 1/52, 1/12, 1/2, 1)
res <- rep(0,5)
for (i in 1:5){
res[[i]] <- Hedge_Simulation(43,43,0.02,0.023,1,100,1000,r_T[[i]])
}
Hedge_Simulation <- function(S_0, K, r, sigma, T, M, N, reb_t){
pnl_mast <- 0
reb_n <- round(reb_t * N)
for (i in 1:M){
s  <- S_0
#if long, the pnl is negative, if short then pnl is positive
pnl_start <- -BS_Call(S_0, K, r, sigma, T) - BS_Put(S_0,K,r,sigma,T)
num_stock <- Call_Delta(S_0, K, r, sigma, T) + Put_Delta(S_0,K,r,sigma, T)
pnl_start <- pnl_start + num_stock*S_0
for (n in 1:N){
#print(num_stock)
s <- s + r*s*(T/N) + sigma * s * rnorm(1) * sqrt(T/N)
if (n %% reb_n == 0){
#print(T-(n/N)*T)
d_call <- Call_Delta(s, K, r, sigma, T-(n/N)*T)
d_put <- Put_Delta(s, K, r, sigma, T-(n/N)*T)
d_tot <- d_call + d_put
num_stock <- d_tot - num_stock
print(num_stock)
pnl_start <- pnl_start + num_stock * s * 0.98
}
}
if (s>=K){
pnl_start <- pnl_start + s-K
} else {
pnl_start <- pnl_start + K-s
}
pnl_mast <- pnl_mast + pnl_start - num_stock * s
}
return (pnl_mast/M)
}
Hedge_Simulation <- function(S_0, K, r, sigma, T, M, N, reb_t){
pnl_mast <- 0
reb_n <- round(reb_t * N)
for (i in 1:M){
s  <- S_0
#if long, the pnl is negative, if short then pnl is positive
pnl_start <- -BS_Call(S_0, K, r, sigma, T) - BS_Put(S_0,K,r,sigma,T)
num_stock <- Call_Delta(S_0, K, r, sigma, T) + Put_Delta(S_0,K,r,sigma, T)
pnl_start <- pnl_start + num_stock*S_0
for (n in 1:N){
#print(num_stock)
s <- s + r*s*(T/N) + sigma * s * rnorm(1) * sqrt(T/N)
if (n %% reb_n == 0){
#print(T-(n/N)*T)
d_call <- Call_Delta(s, K, r, sigma, T-(n/N)*T)
d_put <- Put_Delta(s, K, r, sigma, T-(n/N)*T)
d_tot <- d_call + d_put
num_stock <- d_tot - num_stock
print(num_stock)
pnl_start <- pnl_start + num_stock * s - 0.02 * abs(num_stock*s)
}
}
if (s>=K){
pnl_start <- pnl_start + s-K
} else {
pnl_start <- pnl_start + K-s
}
pnl_mast <- pnl_mast + pnl_start - num_stock * s
}
return (pnl_mast/M)
}
r_T <- c(1/365, 1/52, 1/12, 1/2, 1)
res <- rep(0,5)
for (i in 1:5){
res[[i]] <- Hedge_Simulation(43,43,0.02,0.023,1,100,1000,r_T[[i]])
}
Hedge_Simulation <- function(S_0, K, r, sigma, T, M, N, reb_t){
pnl_mast <- 0
reb_n <- round(reb_t * N)
for (i in 1:M){
s  <- S_0
#if long, the pnl is negative, if short then pnl is positive
pnl_start <- -BS_Call(S_0, K, r, sigma, T) - BS_Put(S_0,K,r,sigma,T)
num_stock <- Call_Delta(S_0, K, r, sigma, T) + Put_Delta(S_0,K,r,sigma, T)
pnl_start <- pnl_start + num_stock*S_0
for (n in 1:N){
#print(num_stock)
s <- s + r*s*(T/N) + sigma * s * rnorm(1) * sqrt(T/N)
if (n %% reb_n == 0){
#print(T-(n/N)*T)
d_call <- Call_Delta(s, K, r, sigma, T-(n/N)*T)
d_put <- Put_Delta(s, K, r, sigma, T-(n/N)*T)
d_tot <- d_call + d_put
num_stock <- d_tot - num_stock
#print(num_stock)
pnl_start <- pnl_start + num_stock * s - 0.02 * abs(num_stock*s)
}
}
if (s>=K){
pnl_start <- pnl_start + s-K
} else {
pnl_start <- pnl_start + K-s
}
pnl_mast <- pnl_mast + pnl_start - num_stock * s
}
return (pnl_mast/M)
}
Hedge_Simulation <- function(S_0, K, r, sigma, T, M, N, reb_t){
pnl_mast <- 0
reb_n <- round(reb_t * N)
for (i in 1:M){
s  <- S_0
#if long, the pnl is negative, if short then pnl is positive
pnl_start <- -BS_Call(S_0, K, r, sigma, T) - BS_Put(S_0,K,r,sigma,T)
num_stock <- Call_Delta(S_0, K, r, sigma, T) + Put_Delta(S_0,K,r,sigma, T)
pnl_start <- pnl_start + num_stock*S_0
for (n in 1:N){
#print(num_stock)
s <- s + r*s*(T/N) + sigma * s * rnorm(1) * sqrt(T/N)
if (n %% reb_n == 0){
#print(T-(n/N)*T)
d_call <- Call_Delta(s, K, r, sigma, T-(n/N)*T)
d_put <- Put_Delta(s, K, r, sigma, T-(n/N)*T)
d_tot <- d_call + d_put
num_stock <- d_tot - num_stock
#print(num_stock)
pnl_start <- pnl_start + num_stock * s - num_stock * 0.05
}
}
if (s>=K){
pnl_start <- pnl_start + s-K
} else {
pnl_start <- pnl_start + K-s
}
pnl_mast <- pnl_mast + pnl_start - num_stock * s
}
return (pnl_mast/M)
}
Hedge_Simulation <- function(S_0, K, r, sigma, T, M, N, reb_t){
pnl_mast <- 0
reb_n <- round(reb_t * N)
for (i in 1:M){
s  <- S_0
#if long, the pnl is negative, if short then pnl is positive
pnl_start <- -BS_Call(S_0, K, r, sigma, T) - BS_Put(S_0,K,r,sigma,T)
num_stock <- Call_Delta(S_0, K, r, sigma, T) + Put_Delta(S_0,K,r,sigma, T)
pnl_start <- pnl_start + num_stock*S_0
for (n in 1:N){
#print(num_stock)
s <- s + r*s*(T/N) + sigma * s * rnorm(1) * sqrt(T/N)
if (n %% reb_n == 0){
#print(T-(n/N)*T)
d_call <- Call_Delta(s, K, r, sigma, T-(n/N)*T)
d_put <- Put_Delta(s, K, r, sigma, T-(n/N)*T)
d_tot <- d_call + d_put
num_stock <- d_tot - num_stock
#print(num_stock)
pnl_start <- pnl_start + num_stock * s - num_stock * 0.005
}
}
if (s>=K){
pnl_start <- pnl_start + s-K
} else {
pnl_start <- pnl_start + K-s
}
pnl_mast <- pnl_mast + pnl_start - num_stock * s
}
return (pnl_mast/M)
}
r_T <- c(1/365, 1/52, 1/12, 1/2, 1)
res <- rep(0,5)
for (i in 1:5){
res[[i]] <- Hedge_Simulation(43,43,0.02,0.023,1,100,1000,r_T[[i]])
}
#print("res")
#print(res)
plot(r_T, res, main = "PnL against rebalancing", ylab = "PnL" , xlab = "rebalance period", type = "l", col = "blue")
r_T <- c(1/365, 1/52, 1/12, 1/2, 1)
res <- rep(0,5)
for (i in 1:5){
res[[i]] <- Hedge_Simulation(43,43,0.02,0.023,1,100,1000,r_T[[i]])
}
#print("res")
#print(res)
plot(r_T, res, main = "PnL against rebalancing", ylab = "PnL" , xlab = "rebalance period", type = "l", col = "blue")
Hedge_Simulation <- function(S_0, K, r, sigma, T, M, N, reb_t){
pnl_mast <- 0
reb_n <- round(reb_t * N)
for (i in 1:M){
s  <- S_0
#if long, the pnl is negative, if short then pnl is positive
pnl_start <- -BS_Call(S_0, K, r, sigma, T) - BS_Put(S_0,K,r,sigma,T)
num_stock <- Call_Delta(S_0, K, r, sigma, T) + Put_Delta(S_0,K,r,sigma, T)
pnl_start <- pnl_start + num_stock*S_0
for (n in 1:N){
#print(num_stock)
s <- s + r*s*(T/N) + sigma * s * rnorm(1) * sqrt(T/N)
if (n %% reb_n == 0){
#print(T-(n/N)*T)
d_call <- Call_Delta(s, K, r, sigma, T-(n/N)*T)
d_put <- Put_Delta(s, K, r, sigma, T-(n/N)*T)
d_tot <- d_call + d_put
num_stock <- d_tot - num_stock
#print(num_stock)
pnl_start <- pnl_start + num_stock * s - num_stock * 0.005
}
}
if (s>=K){
pnl_start <- pnl_start + s-K
} else {
pnl_start <- pnl_start + K-s
}
pnl_mast <- pnl_mast + pnl_start - num_stock * s
}
return (pnl_mast/M)
}
knitr::opts_chunk$set(echo = TRUE)
BS_Call <- function(S_0, K, r, sigma, T){
d1 <- (log(S_0/K) + (r + sigma^2/2)*T)/(sigma * sqrt(T))
d2 <- (log(S_0/K) + (r - sigma^2/2)*T)/(sigma * sqrt(T))
res <- S_0 * pnorm(d1) - K*pnorm(d2) * exp(-r * T)
return(res)
}
BS_Put <- function(S_0, K, r, sigma, T){
d1 <- (log(S_0/K) + (r + sigma^2/2)*T)/(sigma * sqrt(T))
d2 <- (log(S_0/K) + (r - sigma^2/2)*T)/(sigma * sqrt(T))
res <- -S_0 * pnorm(-d1) + K*pnorm(-d2) * exp(-r * T)
return(res)
}
Call_Delta <- function(S_0, K, r, sigma, T){
d1 <- (log(S_0/K) + (r + sigma^2/2)*T)/(sigma * sqrt(T))
## print("yay call")
# print(d1)
res <- pnorm(d1)
#print(res)
return(res)
}
Put_Delta <- function(S_0, K, r, sigma, T){
d1 <- (log(S_0/K) + (r + sigma^2/2)*T)/(sigma * sqrt(T))
#print("Yay put")
#print(T)
#print(d1)
res <- -(pnorm(-d1))
#print(res)
return(res)
}
Hedge_Simulation <- function(S_0, K, r, sigma, T, M, N, reb_t){
pnl_mast <- 0
reb_n <- round(reb_t * N)
for (i in 1:M){
s  <- S_0
#if long, the pnl is negative, if short then pnl is positive
pnl_start <- -BS_Call(S_0, K, r, sigma, T) - BS_Put(S_0,K,r,sigma,T)
num_stock <- Call_Delta(S_0, K, r, sigma, T) + Put_Delta(S_0,K,r,sigma, T)
pnl_start <- pnl_start + num_stock*S_0
for (n in 1:N){
#print(num_stock)
s <- s + r*s*(T/N) + sigma * s * rnorm(1) * sqrt(T/N)
if (n %% reb_n == 0){
#print(T-(n/N)*T)
d_call <- Call_Delta(s, K, r, sigma, T-(n/N)*T)
d_put <- Put_Delta(s, K, r, sigma, T-(n/N)*T)
d_tot <- d_call + d_put
num_stock <- d_tot - num_stock
#print(num_stock)
pnl_start <- pnl_start + num_stock * s - num_stock * 0.005
}
}
if (s>=K){
pnl_start <- pnl_start + s-K
} else {
pnl_start <- pnl_start + K-s
}
pnl_mast <- pnl_mast + pnl_start - num_stock * s
}
return (pnl_mast/M)
}
r_T <- c(1/365, 1/52, 1/12, 1/2, 1)
res <- rep(0,5)
for (i in 1:5){
res[[i]] <- Hedge_Simulation(43,43,0.02,0.023,1,100,1000,r_T[[i]])
}
#print("res")
#print(res)
plot(r_T, res, main = "PnL against rebalancing", ylab = "PnL" , xlab = "rebalance period", type = "l", col = "blue")
Hedge_Simulation <- function(S_0, K, r, sigma, T, M, N, reb_t){
pnl_mast <- 0
reb_n <- round(reb_t * N)
for (i in 1:M){
s  <- S_0
#if long, the pnl is negative, if short then pnl is positive
pnl_start <- -BS_Call(S_0, K, r, sigma, T) - BS_Put(S_0,K,r,sigma,T)
num_stock <- Call_Delta(S_0, K, r, sigma, T) + Put_Delta(S_0,K,r,sigma, T)
pnl_start <- pnl_start + num_stock*S_0
for (n in 1:N){
#print(num_stock)
s <- s + r*s*(T/N) + sigma * s * rnorm(1) * sqrt(T/N)
if (n %% reb_n == 0){
#print(T-(n/N)*T)
d_call <- Call_Delta(s, K, r, sigma, T-(n/N)*T)
d_put <- Put_Delta(s, K, r, sigma, T-(n/N)*T)
d_tot <- d_call + d_put
num_stock <- d_tot - num_stock
#print(num_stock)
pnl_start <- pnl_start + num_stock * s - num_stock * 0.005
}
}
if (s>=K){
pnl_start <- pnl_start + s-K
} else {
pnl_start <- pnl_start + K-s
}
pnl_mast <- pnl_mast + pnl_start - num_stock * s
}
return (pnl_mast/M)
}
r_T <- c(1/365, 1/52, 1/12, 1/2, 1)
res <- rep(0,5)
for (i in 1:5){
res[[i]] <- Hedge_Simulation(43,43,0.02,0.023,1,100,1000,r_T[[i]])
}
#print("res")
#print(res)
plot(r_T, res, main = "PnL against rebalancing", ylab = "PnL" , xlab = "rebalance period", type = "l", col = "blue")
