---
title: "Google_Thesis_Callibration"
output: html_document
---

```{r}
library("NMOF")
library("plotly")
```

Load data
```{r}
may = read.delim("GOOG04062013.dat",header=FALSE,sep=",")
sep = read.delim("GOOG09202013.dat",header=FALSE,sep=",")
jan = read.delim("GOOG01172014.dat",header=FALSE,sep=",")



option_data = rbind(rbind(may, sep), jan)
mkt_px = option_data[,5]
num_data = length(mkt_px)

```


MSE Code
```{r}

MSE <- function(vec1, vec2){
  ms <- (vec1-vec2)^2
  return ((sum(ms))^0.5)/length(vec1)
}


GOOGL_Opt <- function(param_vectors){
  a <- param_vectors[[1]]
  theta <- param_vectors[[2]]
  miu <- param_vectors[[3]]
  rho<- param_vectors[[4]]
  kappa <- (a + miu^2)/(2*theta)
  sv_est = rep(0, num_data)
  for (i in 1:num_data){
    r = option_data[i,1]
    tau = option_data[i,2]
    S = option_data[i,3]
    K = option_data[i,4]
    sv_est[[i]] = callHestoncf(S, K, tau/252, r, 0 ,sqrt(0.069545829), theta, rho, kappa, miu)
  }
  return (MSE(sv_est, mkt_px))
}

```


Callibration using grid search
```{r}
grid_search <- function(kappa, theta, deltaK, deltaT){
  min <- GOOGL_Opt(c(kappa, theta, 0.001, -0.2))
  minK <- kappa
  minT <- theta
  for(dk in c(-deltaK, 0, deltaK)){
    for (dt in c(-deltaT, 0, deltaT)){
      curr <- GOOGL_Opt(c(kappa + dk, theta + dt, 0.001, -0.2))
      if (curr<min){
        min <- curr
        minK <- kappa + dk
        minT <- theta + dt
      }
    }
  }
  if (minK<0){
    minK = kappa
  }
  if (minT <0){
    minT = theta
  }
  if (minK == kappa && minT == theta){
    deltaK <- deltaK/2
    deltaT <- deltaT/2
  } 
  return (c(minK, minT,deltaK, deltaT))
  
}

oldk <- 2.040210844 * 2 * 0.053565543 - 0.467514601^2 
oldt <- 0.053565543
newk <- 2.040210844 * 2 * 0.053565543 - 0.467514601^2 
newt<- 0.053565543
deltaK <- 0.0000000001
deltaT <- 0.01
new_vecs<-c(2,1)
while (deltaK>0.00000000001 && deltaT > 0.00001){
  oldk<-newk
  oldt<-newt
  old_vecs <- c(oldk, oldt, 0.467514601, -0.50903932)
  new_vecs <- grid_search(oldk, oldt, deltaK, deltaT)
  newk<- new_vecs[[1]]
  newt <- new_vecs[[2]]
  deltaK <- new_vecs[[3]]
  deltaT <- new_vecs[[4]]
  print((newk + 0.467514601^2)/(2*newt))
  print(newt)
}

print((newk + 0.467514601^2)/(2*newt))
print(newt)

```

```{r}
options(digits = 10)
GOOGL_Opt(c(1.827034 * 2 * 0.05981554 - 0.467514601^2, 0.05981554,0.467514601,-0.50903932))
GOOGL_Opt(c(2.040210844 * 2 * 0.05981554 - 0.467514601^2, 0.053565543,0.467514601,-0.50903932))
```
Plot Error Function
```{r}
kappas <- c(seq(0.1,3,0.1))
thetas <- c(seq(0.05,1,0.05))
errors <- matrix(0, nrow=length(kappas), ncol=length(thetas))
for (i in 1:length(kappas)){
  for (j in 1:length(thetas)){
    a <- kappas[[i]]*2*thetas[[j]] - 0.467514601^2
    errors[i,j] = GOOGL_Opt(c(a,thetas[[j]],0.467514601,-0.50903932))
  }
}

```

# ```{r}
# x <- c(1:6)
# y <- c(1:5)
# z<- matrix(0, nrow=6,ncol=5)
# for (i in 1:6){
#   for (j in 1:5){
#     z[i,j] = x[i] * y[j]
#   }
# }
# plot_ly() %>% add_surface(x=y, y=x, z=z)
# ```

```{r}
plot_ly() %>% add_surface(x=thetas, y=kappas, z=errors)
``` 

