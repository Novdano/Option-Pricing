#Callibrate a and theta
min1 <- MSFT_Opt(c(a, theta, nu, rho))
minA <- a
minT <- theta
for (dA in c(-deltaA, 0, deltaA)){
for(dT in c(-deltaT, 0, deltaT)){
currA <- a + dA
currT <- theta + dt
print(currA)
print(currT)
if (currT<0 || currT > 1 || currA <0 || ((currA +miu^2) /(2*currT))<0){
next
}
curr <- MSFT_Opt(c(a + dA, theta + dT, nu, rho))
#print(currA, currT)
if (curr < min1){
minA <- a + dA
minT <- t + dT
min1 <- curr
}
}
}
if (minT < 0 || minT >1){
minT <- theta
}
if (minA <0 || (minA + nu^2)/(2*minT)){
minA <- a
}
if(minA==a && minT ==theta){
deltaA = deltaA/2
deltaT = deltaT/2
}
a < minA
theta <- minT
#Callibrate Nu and Rho
min2 <- MSFT_Opt(c(a, theta, nu, rho))
minN <- nu
minR <- rho
for (dN in c(-deltaNu, 0, deltaNu)){
for(dR in c(-deltaRho, 0, deltaRho)){
currN <- nu + dN
currR <- rho + dR
if (currN < 0 || currN >1 || currR <-1 || currR>1){
next
}
#print(currN, currR)
curr <- MSFT_Opt(c(a, theta, nu+dN, rho+dR))
if (curr < min2){
minN <- nu + dN
minR <- rho + dR
min2 <- curr
}
}
}
if (minN < 0 || minN >1){
minN <- nu
}
if (minR <-1 || minR>1){
minR <- rho
}
if(minR==rho && minN ==nu){
deltaNu = deltaNu/2
deltaRho = deltaRho/2
}
nu <- minN
rho <- minR
return (c(a, theta, nu, rho, deltaA, deltaT, deltaNu, deltaRho))
}
MSE <- function(vec1, vec2){
ms <- (vec1-vec2)^2
return ((sum(ms))^0.5)/length(vec1)
}
MSFT_Opt <- function(params){
a<- params[[1]]
theta <- params[[2]]
nu <- params[[3]]
rho <- params[[4]]
kappa <- (a + nu^2) /(2*theta)
px_est <- rep(0,N)
for (i in 1:N){
r=0.0175
K <- calls[i,1]
date <- as.Date(calls[i,2], "%m/%d/%y")
mkt_px <- calls[i,5]
sigma0 <- calls[i,6]
tau <- as.numeric(date-curr_date)/252
print(c(S, K, tau, r, sigma0, theta, rho, kappa, nu))
px_est[[i]] <- callHestoncf(S, K, tau, r, 0 ,sigma0, theta, rho, kappa, nu)
}
return (MSE(px_est,calls[[5]]))
}
kappa <- 2
theta <- 0.8
nu <- 1e-10
rho <- 0.1
a <- kappa * 2 * theta - nu^2
grid_descend_MSFT(c(a, theta, nu, rho))
MSE <- function(vec1, vec2){
ms <- (vec1-vec2)^2
return ((sum(ms))^0.5)/length(vec1)
}
MSFT_Opt <- function(params){
a<- params[[1]]
theta <- params[[2]]
nu <- params[[3]]
rho <- params[[4]]
kappa <- (a + nu^2) /(2*theta)
px_est <- rep(0,N)
for (i in 1:N){
r=0.0175
K <- calls[i,1]
date <- as.Date(calls[i,2], "%m/%d/%y")
mkt_px <- calls[i,5]
sigma0 <- calls[i,6]
tau <- as.numeric(date-curr_date)/252
print(c(S, K, tau, r, sigma0, theta, rho, kappa, nu))
px_est[[i]] <- callHestoncf(S, K, tau, r, 0 ,sigma0/100, theta, rho, kappa, nu)
}
return (MSE(px_est,calls[[5]]))
}
MSE <- function(vec1, vec2){
ms <- (vec1-vec2)^2
return ((sum(ms))^0.5)/length(vec1)
}
MSFT_Opt <- function(params){
a<- params[[1]]
theta <- params[[2]]
nu <- params[[3]]
rho <- params[[4]]
kappa <- (a + nu^2) /(2*theta)
px_est <- rep(0,N)
for (i in 1:N){
r=0.0175
K <- calls[i,1]
date <- as.Date(calls[i,2], "%m/%d/%y")
mkt_px <- calls[i,5]
sigma0 <- calls[i,6]
tau <- as.numeric(date-curr_date)/252
#print(c(S, K, tau, r, sigma0, theta, rho, kappa, nu))
px_est[[i]] <- callHestoncf(S, K, tau, r, 0 ,sigma0/100, theta, rho, kappa, nu)
}
return (MSE(px_est,calls[[5]]))
}
kappa <- 2
theta <- 0.8
nu <- 1e-3
rho <- 0.1
a <- kappa * 2 * theta - nu^2
grid_descend_MSFT(c(a, theta, nu, rho))
grid_search_hest <- function(a, theta, nu, rho, deltaA, deltaT, deltaNu, deltaRho){
#Callibrate a and theta
min1 <- MSFT_Opt(c(a, theta, nu, rho))
minA <- a
minT <- theta
for (dA in c(-deltaA, 0, deltaA)){
for(dT in c(-deltaT, 0, deltaT)){
currA <- a + dA
currT <- theta + dT
print(currA)
print(currT)
if (currT<0 || currT > 1 || currA <0 || ((currA +miu^2) /(2*currT))<0){
next
}
curr <- MSFT_Opt(c(a + dA, theta + dT, nu, rho))
#print(currA, currT)
if (curr < min1){
minA <- a + dA
minT <- t + dT
min1 <- curr
}
}
}
if (minT < 0 || minT >1){
minT <- theta
}
if (minA <0 || (minA + nu^2)/(2*minT)){
minA <- a
}
if(minA==a && minT ==theta){
deltaA = deltaA/2
deltaT = deltaT/2
}
a < minA
theta <- minT
#Callibrate Nu and Rho
min2 <- MSFT_Opt(c(a, theta, nu, rho))
minN <- nu
minR <- rho
for (dN in c(-deltaNu, 0, deltaNu)){
for(dR in c(-deltaRho, 0, deltaRho)){
currN <- nu + dN
currR <- rho + dR
if (currN < 0 || currN >1 || currR <-1 || currR>1){
next
}
#print(currN, currR)
curr <- MSFT_Opt(c(a, theta, nu+dN, rho+dR))
if (curr < min2){
minN <- nu + dN
minR <- rho + dR
min2 <- curr
}
}
}
if (minN < 0 || minN >1){
minN <- nu
}
if (minR <-1 || minR>1){
minR <- rho
}
if(minR==rho && minN ==nu){
deltaNu = deltaNu/2
deltaRho = deltaRho/2
}
nu <- minN
rho <- minR
return (c(a, theta, nu, rho, deltaA, deltaT, deltaNu, deltaRho))
}
grid_search_hest <- function(a, theta, nu, rho, deltaA, deltaT, deltaNu, deltaRho){
#Callibrate a and theta
min1 <- MSFT_Opt(c(a, theta, nu, rho))
minA <- a
minT <- theta
for (dA in c(-deltaA, 0, deltaA)){
for(dT in c(-deltaT, 0, deltaT)){
currA <- a + dA
currT <- theta + dT
print(currA)
print(currT)
if (currT<0 || currT > 1 || currA <0 || ((currA +miu^2) /(2*currT))<0){
next
}
curr <- MSFT_Opt(c(a + dA, theta + dT, nu, rho))
#print(currA, currT)
if (curr < min1){
minA <- a + dA
minT <- theta + dT
min1 <- curr
}
}
}
if (minT < 0 || minT >1){
minT <- theta
}
if (minA <0 || (minA + nu^2)/(2*minT)){
minA <- a
}
if(minA==a && minT ==theta){
deltaA = deltaA/2
deltaT = deltaT/2
}
a < minA
theta <- minT
#Callibrate Nu and Rho
min2 <- MSFT_Opt(c(a, theta, nu, rho))
minN <- nu
minR <- rho
for (dN in c(-deltaNu, 0, deltaNu)){
for(dR in c(-deltaRho, 0, deltaRho)){
currN <- nu + dN
currR <- rho + dR
if (currN < 0 || currN >1 || currR <-1 || currR>1){
next
}
#print(currN, currR)
curr <- MSFT_Opt(c(a, theta, nu+dN, rho+dR))
if (curr < min2){
minN <- nu + dN
minR <- rho + dR
min2 <- curr
}
}
}
if (minN < 0 || minN >1){
minN <- nu
}
if (minR <-1 || minR>1){
minR <- rho
}
if(minR==rho && minN ==nu){
deltaNu = deltaNu/2
deltaRho = deltaRho/2
}
nu <- minN
rho <- minR
return (c(a, theta, nu, rho, deltaA, deltaT, deltaNu, deltaRho))
}
kappa <- 2
theta <- 0.8
nu <- 1e-3
rho <- 0.1
a <- kappa * 2 * theta - nu^2
grid_descend_MSFT(c(a, theta, nu, rho))
grid_search_hest <- function(a, theta, nu, rho, deltaA, deltaT, deltaNu, deltaRho){
#Callibrate a and theta
min1 <- MSFT_Opt(c(a, theta, nu, rho))
minA <- a
minT <- theta
for (dA in c(-deltaA, 0, deltaA)){
for(dT in c(-deltaT, 0, deltaT)){
currA <- a + dA
currT <- theta + dT
print(currA)
print(currT)
if (currT<0 || currT > 1 || currA <0 || ((currA +nu^2) /(2*currT))<0){
next
}
curr <- MSFT_Opt(c(a + dA, theta + dT, nu, rho))
#print(currA, currT)
if (curr < min1){
minA <- a + dA
minT <- theta + dT
min1 <- curr
}
}
}
if (minT < 0 || minT >1){
minT <- theta
}
if (minA <0 || (minA + nu^2)/(2*minT)){
minA <- a
}
if(minA==a && minT ==theta){
deltaA = deltaA/2
deltaT = deltaT/2
}
a < minA
theta <- minT
#Callibrate Nu and Rho
min2 <- MSFT_Opt(c(a, theta, nu, rho))
minN <- nu
minR <- rho
for (dN in c(-deltaNu, 0, deltaNu)){
for(dR in c(-deltaRho, 0, deltaRho)){
currN <- nu + dN
currR <- rho + dR
if (currN < 0 || currN >1 || currR <-1 || currR>1){
next
}
#print(currN, currR)
curr <- MSFT_Opt(c(a, theta, nu+dN, rho+dR))
if (curr < min2){
minN <- nu + dN
minR <- rho + dR
min2 <- curr
}
}
}
if (minN < 0 || minN >1){
minN <- nu
}
if (minR <-1 || minR>1){
minR <- rho
}
if(minR==rho && minN ==nu){
deltaNu = deltaNu/2
deltaRho = deltaRho/2
}
nu <- minN
rho <- minR
return (c(a, theta, nu, rho, deltaA, deltaT, deltaNu, deltaRho))
}
grid_search_hest <- function(a, theta, nu, rho, deltaA, deltaT, deltaNu, deltaRho){
#Callibrate a and theta
min1 <- MSFT_Opt(c(a, theta, nu, rho))
minA <- a
minT <- theta
for (dA in c(-deltaA, 0, deltaA)){
for(dT in c(-deltaT, 0, deltaT)){
currA <- a + dA
currT <- theta + dT
print(currA)
print(currT)
if (currT<0 || currT > 1 || currA <0 || ((currA +nu^2) /(2*currT))<0){
next
}
curr <- MSFT_Opt(c(a + dA, theta + dT, nu, rho))
#print(currA, currT)
if (curr < min1){
minA <- a + dA
minT <- theta + dT
min1 <- curr
}
}
}
if (minT < 0 || minT >1){
minT <- theta
}
if (minA <0 || (minA + nu^2)/(2*minT)){
minA <- a
}
if(minA==a && minT ==theta){
deltaA = deltaA/2
deltaT = deltaT/2
}
a < minA
theta <- minT
#Callibrate Nu and Rho
min2 <- MSFT_Opt(c(a, theta, nu, rho))
minN <- nu
minR <- rho
for (dN in c(-deltaNu, 0, deltaNu)){
for(dR in c(-deltaRho, 0, deltaRho)){
currN <- nu + dN
currR <- rho + dR
if (currN < 0 || currN >1 || currR <-1 || currR>1){
next
}
#print(currN, currR)
curr <- MSFT_Opt(c(a, theta, nu+dN, rho+dR))
if (curr < min2){
minN <- nu + dN
minR <- rho + dR
min2 <- curr
}
}
}
if (minN < 0 || minN >1){
minN <- nu
}
if (minR <-1 || minR>1){
minR <- rho
}
if(minR==rho && minN ==nu){
deltaNu = deltaNu/2
deltaRho = deltaRho/2
}
nu <- minN
rho <- minR
return (c(a, theta, nu, rho, deltaA, deltaT, deltaNu, deltaRho))
}
kappa <- 2
theta <- 0.8
nu <- 1e-3
rho <- 0.1
a <- kappa * 2 * theta - nu^2
grid_descend_MSFT(c(a, theta, nu, rho))
grid_search_hest <- function(a, theta, nu, rho, deltaA, deltaT, deltaNu, deltaRho){
#Callibrate a and theta
min1 <- MSFT_Opt(c(a, theta, nu, rho))
minA <- a
minT <- theta
for (dA in c(-deltaA, 0, deltaA)){
for(dT in c(-deltaT, 0, deltaT)){
currA <- a + dA
currT <- theta + dT
print(currA)
print(currT)
if (currT<0 || currT > 1 || currA <0 || ((currA +nu^2) /(2*currT))<0){
next
}
curr <- MSFT_Opt(c(a + dA, theta + dT, nu, rho))
#print(currA, currT)
if (curr < min1){
minA <- a + dA
minT <- theta + dT
min1 <- curr
}
}
}
if (minT < 0 || minT >1){
minT <- theta
}
if (minA <0 || (minA + nu^2)/(2*minT)){
minA <- a
}
if(minA==a && minT ==theta){
deltaA = deltaA/2
deltaT = deltaT/2
}
a < minA
theta <- minT
#Callibrate Nu and Rho
min2 <- MSFT_Opt(c(a, theta, nu, rho))
minN <- nu
minR <- rho
for (dN in c(-deltaNu, 0, deltaNu)){
for(dR in c(-deltaRho, 0, deltaRho)){
currN <- nu + dN
currR <- rho + dR
if (currN < 0 || currN >1 || currR <1 || currR>1){
next
}
#print(currN, currR)
curr <- MSFT_Opt(c(a, theta, nu+dN, rho+dR))
if (curr < min2){
minN <- nu + dN
minR <- rho + dR
min2 <- curr
}
}
}
if (minN < 0 || minN >1){
minN <- nu
}
if (minR <-1 || minR>1){
minR <- rho
}
if(minR==rho && minN ==nu){
deltaNu = deltaNu/2
deltaRho = deltaRho/2
}
nu <- minN
rho <- minR
return (c(a, theta, nu, rho, deltaA, deltaT, deltaNu, deltaRho))
}
kappa <- 2
theta <- 0.8
nu <- 1e-3
rho <- 0.1
a <- kappa * 2 * theta - nu^2
grid_descend_MSFT(c(a, theta, nu, rho))
