---
title: "SABR_MC"
output: html_document
---

```{r}
#install.packages("pracma")
library("NMOF")
library("pracma")
```

```{r}
options = c(7.7,6.4,5.02,2.79,1.42);
K = c(95,97.5,100,105,110);
S = 100;

MSE <- function(vec1, vec2){
  ms <- (vec1-vec2)^2
  return ((sum(ms))^0.5)/length(vec1)
}

MSFT_Opt_SV <- function(param_vectors){
  a <- param_vectors[[1]]
  theta <- param_vectors[[2]]
  miu <- param_vectors[[3]]
  rho<- param_vectors[[4]]
  kappa <- (a + miu^2)/(2*theta)
  sv_est = rep(0, length(K))
  for (i in 1:length(K)){
    sv_est[[i]] <- callHestoncf(S, K[[i]], 1/3, 0.02, 0 ,0.16, theta, rho, kappa, miu)
  }
  return (MSE(sv_est, options))
}

MSFT_Opt_SABR <- function(param_vectors){
  alpha <- param_vectors[[1]]
  beta <- param_vectors[[2]]
  rho <- param_vectors[[3]]
  nu<- param_vectors[[4]]
  sv_est = rep(0, length(K))
  for (i in 1:length(K)){
    sv_est[[i]] <- SABR_MC_Call(S,K[[i]], 0.02 ,alpha, beta, rho, nu, 1/3, 100,100)
  }
  return (MSE(sv_est, options))
}
```

```{r}
grid_search_SV <- function(kappa, theta, deltaK, deltaT){
  min <- MSFT_Opt_SV(c(kappa, theta, 0.001, 0.3))
  minK <- kappa
  minT <- theta
  for(dk in c(-deltaK, 0, deltaK)){
    for (dt in c(-deltaT, 0, deltaT)){
      curr <- MSFT_Opt_SV(c(kappa + dk, theta + dt, 0.001, 0.3))
      if (curr<min){
        if (kappa + dk >0 && theta + dt >0){
          min <- curr
          minK <- kappa + dk
          minT <- theta + dt 
        }
      }
    }
  }
  if (minK == kappa && minT == theta){
    deltaK <- deltaK/2
    deltaT <- deltaT/2
  } 
  return (c(minK, minT,deltaK, deltaT))
}
oldk <- 0.5
oldt <- 0.7
newk <- 0.5
newt<- 0.7
deltaK <- 0.01
deltaT <- 0.01
new_vecs<-c(2,1)
while (deltaK>0.0001 && deltaT > 0.0001){
  oldk<-newk
  oldt<-newt
  old_vecs <- c(oldk, oldt, oldm, oldr)
  new_vecs <- grid_search_SV(oldk, oldt, deltaK, deltaT)
  newk<- new_vecs[[1]]
  newt <- new_vecs[[2]]
  deltaK <- new_vecs[[3]]
  deltaT <- new_vecs[[4]]
  print(newk)
  print(newt)
}

print(newk)
print(newt)



```

```{r}
grid_search_SABR <- function(alpha, deltaA){
  min <- MSFT_Opt_SABR(c(alpha, 1, 0.3, 0.4))
  minA <- alpha
  for(da in c(-deltaA, 0, deltaA)){
      curr <- MSFT_Opt_SABR(c(alpha+da, 1, 0.3, 0.4))
      if (curr<min){
        min <- curr
        minA <- alpha + da
      }
  }
  if (minA == alpha){
    deltaA <- deltaA/2
  } 
  return (c(alpha, deltaA))
}

oldk <- 0.5
oldt <- 0.7
newk <- 0.5
newt<- 0.7
deltaK <- 0.01
deltaT <- 0.01
new_vecs<-c(2,1)
while (deltaK>0.0001 && deltaT > 0.0001){
  oldk<-newk
  oldt<-newt
  old_vecs <- c(oldk, oldt, oldm, oldr)
  new_vecs <- grid_search_SV(oldk, oldt, deltaK, deltaT)
  newk<- new_vecs[[1]]
  newt <- new_vecs[[2]]
  deltaK <- new_vecs[[3]]
  deltaT <- new_vecs[[4]]
}

print(newk)
print(newt)

```

SABR Call Monte Carlo
```{r}
SABR_MC_Call <- function(S_0, K, r, alpha_0, beta, rho, nu, T, M, N){
  payoff <- 0
  for(i in 1:M){
    S <- S_0
    alpha <- alpha_0
    for(n in 1:N){
      W1 <- rnorm(1)
      W2 <- rnorm(1)
      S <- S + r*S*(T/N) + alpha*S^beta*sqrt(T/N)*W1*(exp((-r*(T-n*(T/N)))))^(1-beta)
      alpha <- alpha + nu*alpha*(rho * W1 + sqrt(1-rho^2)*W2)*sqrt(T/N)
    }
    if (S>K){
      payoff <- payoff + S-K
    }
  }
  return ((payoff/M) * (1+r*(T/N))^-N)
}

SABR_MC_Call(50,30,0.02,0.4,1,0.3,0.4,1/12,100,100)
SABR_MC_Call(50,30,0.02,0.8,1,0.3,0.4,1/12,100,100)
SABR_MC_Call(50,30,0.02,0.4,1,0.6,0.4,1/12,100,100)
SABR_MC_Call(50,30,0.02,0.4,1,0.3,0.8,1/12,100,100)
```
Stochastic Volatility Call Code
```{r}
SV_MC_Call <- function(S_0, K, r, sigma_0, kappa, theta, miu, rho, lambda, T, N, M){
  payoff <- rep(0,M)
  for (i in 1:M){
    s <- S_0
    v<- sigma_0
    vols = rep(0,N)
    for (n in 1:N){
      gts = rnorm(1)
      gtv = rnorm(1)
      s <- s + r*s*(T/N) + sqrt(v) * s * gts * sqrt(T/N)
      v <- v + kappa*(theta-v)*(T/N) + miu*sqrt(v)*sqrt(T/N)*(rho*(gts) + sqrt(1-rho^2)*gtv)
      #vols[[n]] = v
    }
    #plot(c(1:N), vols,main = "vol evolution",ylab="Vols",xlab="Time",type="l")
    if (s>K){
      payoff[[i]] <- s-K
    } else{
      payoff[[i]] <- 0
    }
  }
  res <- (1 + r * (T/N))^-N * mean(payoff)
  return (res)
}
```



